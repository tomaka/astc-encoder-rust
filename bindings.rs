/* automatically generated by rust-bindgen 0.71.1 */

pub const _GLIBCXX_CSTDDEF: u32 = 1;
pub const _GLIBCXX_CXX_CONFIG_H: u32 = 1;
pub const _GLIBCXX_RELEASE: u32 = 14;
pub const __GLIBCXX__: u32 = 20250212;
pub const _GLIBCXX_HAVE_ATTRIBUTE_VISIBILITY: u32 = 1;
pub const _GLIBCXX_USE_DEPRECATED: u32 = 1;
pub const _GLIBCXX_EXTERN_TEMPLATE: u32 = 1;
pub const _GLIBCXX_USE_DUAL_ABI: u32 = 1;
pub const _GLIBCXX_USE_CXX11_ABI: u32 = 1;
pub const _GLIBCXX_INLINE_VERSION: u32 = 0;
pub const _GLIBCXX_HAVE_IS_CONSTANT_EVALUATED: u32 = 1;
pub const _GLIBCXX_VERBOSE_ASSERT: u32 = 1;
pub const _GLIBCXX_USE_ALLOCATOR_NEW: u32 = 1;
pub const _GLIBCXX_OS_DEFINES: u32 = 1;
pub const __NO_CTYPE: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _ISOC95_SOURCE: u32 = 1;
pub const _ISOC99_SOURCE: u32 = 1;
pub const _ISOC11_SOURCE: u32 = 1;
pub const _ISOC23_SOURCE: u32 = 1;
pub const _ISOC2Y_SOURCE: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const _XOPEN_SOURCE: u32 = 700;
pub const _XOPEN_SOURCE_EXTENDED: u32 = 1;
pub const _LARGEFILE64_SOURCE: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const _DYNAMIC_STACK_SIZE_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2Y: u32 = 1;
pub const __GLIBC_USE_ISOC23: u32 = 1;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_ISOCXX11: u32 = 1;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const __USE_XOPEN: u32 = 1;
pub const __USE_XOPEN_EXTENDED: u32 = 1;
pub const __USE_UNIX98: u32 = 1;
pub const _LARGEFILE_SOURCE: u32 = 1;
pub const __USE_XOPEN2K8XSI: u32 = 1;
pub const __USE_XOPEN2KXSI: u32 = 1;
pub const __USE_LARGEFILE: u32 = 1;
pub const __USE_LARGEFILE64: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 0;
pub const __TIMESIZE: u32 = 64;
pub const __USE_TIME_BITS64: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_DYNAMIC_STACK_SIZE: u32 = 1;
pub const __USE_GNU: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const __GLIBC_USE_C23_STRTOL: u32 = 1;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 41;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 0;
pub const _GLIBCXX_MAY_HAVE___CXA_THREAD_ATEXIT_IMPL: u32 = 1;
pub const _GLIBCXX_GTHREAD_USE_WEAK: u32 = 0;
pub const _GLIBCXX_CPU_DEFINES: u32 = 1;
pub const _GLIBCXX_USE_STD_SPEC_FUNCS: u32 = 1;
pub const _GLIBCXX_FAST_MATH: u32 = 0;
pub const _GLIBCXX_FLOAT_IS_IEEE_BINARY32: u32 = 1;
pub const _GLIBCXX_DOUBLE_IS_IEEE_BINARY64: u32 = 1;
pub const _GLIBCXX_LDOUBLE_IS_IEEE_BINARY128: u32 = 1;
pub const _GLIBCXX_HAVE_BUILTIN_HAS_UNIQ_OBJ_REP: u32 = 1;
pub const _GLIBCXX_HAVE_BUILTIN_IS_AGGREGATE: u32 = 1;
pub const _GLIBCXX_HAVE_BUILTIN_LAUNDER: u32 = 1;
pub const _PSTL_VERSION: u32 = 17000;
pub const _PSTL_VERSION_MAJOR: u32 = 17;
pub const _PSTL_VERSION_MINOR: u32 = 0;
pub const _PSTL_VERSION_PATCH: u32 = 0;
pub const _PSTL_USAGE_WARNINGS: u32 = 0;
pub const _PSTL_PRAGMA_LOCATION: &[u8; 26] = b" [Parallel STL message]: \0";
pub const _GLIBCXX_HAVE_ACOSF: u32 = 1;
pub const _GLIBCXX_HAVE_ACOSL: u32 = 1;
pub const _GLIBCXX_HAVE_ALIGNED_ALLOC: u32 = 1;
pub const _GLIBCXX_HAVE_ARC4RANDOM: u32 = 1;
pub const _GLIBCXX_HAVE_ARPA_INET_H: u32 = 1;
pub const _GLIBCXX_HAVE_ASINF: u32 = 1;
pub const _GLIBCXX_HAVE_ASINL: u32 = 1;
pub const _GLIBCXX_HAVE_AS_SYMVER_DIRECTIVE: u32 = 1;
pub const _GLIBCXX_HAVE_ATAN2F: u32 = 1;
pub const _GLIBCXX_HAVE_ATAN2L: u32 = 1;
pub const _GLIBCXX_HAVE_ATANF: u32 = 1;
pub const _GLIBCXX_HAVE_ATANL: u32 = 1;
pub const _GLIBCXX_HAVE_ATOMIC_LOCK_POLICY: u32 = 1;
pub const _GLIBCXX_HAVE_AT_QUICK_EXIT: u32 = 1;
pub const _GLIBCXX_HAVE_C99_FLT_EVAL_TYPES: u32 = 1;
pub const _GLIBCXX_HAVE_CEILF: u32 = 1;
pub const _GLIBCXX_HAVE_CEILL: u32 = 1;
pub const _GLIBCXX_HAVE_COMPLEX_H: u32 = 1;
pub const _GLIBCXX_HAVE_COSF: u32 = 1;
pub const _GLIBCXX_HAVE_COSHF: u32 = 1;
pub const _GLIBCXX_HAVE_COSHL: u32 = 1;
pub const _GLIBCXX_HAVE_COSL: u32 = 1;
pub const _GLIBCXX_HAVE_DECL_STRNLEN: u32 = 1;
pub const _GLIBCXX_HAVE_DIRENT_H: u32 = 1;
pub const _GLIBCXX_HAVE_DIRFD: u32 = 1;
pub const _GLIBCXX_HAVE_DLFCN_H: u32 = 1;
pub const _GLIBCXX_HAVE_ENDIAN_H: u32 = 1;
pub const _GLIBCXX_HAVE_EXCEPTION_PTR_SINCE_GCC46: u32 = 1;
pub const _GLIBCXX_HAVE_EXECINFO_H: u32 = 1;
pub const _GLIBCXX_HAVE_EXPF: u32 = 1;
pub const _GLIBCXX_HAVE_EXPL: u32 = 1;
pub const _GLIBCXX_HAVE_FABSF: u32 = 1;
pub const _GLIBCXX_HAVE_FABSL: u32 = 1;
pub const _GLIBCXX_HAVE_FCNTL_H: u32 = 1;
pub const _GLIBCXX_HAVE_FDOPENDIR: u32 = 1;
pub const _GLIBCXX_HAVE_FENV_H: u32 = 1;
pub const _GLIBCXX_HAVE_FINITE: u32 = 1;
pub const _GLIBCXX_HAVE_FINITEF: u32 = 1;
pub const _GLIBCXX_HAVE_FINITEL: u32 = 1;
pub const _GLIBCXX_HAVE_FLOAT_H: u32 = 1;
pub const _GLIBCXX_HAVE_FLOORF: u32 = 1;
pub const _GLIBCXX_HAVE_FLOORL: u32 = 1;
pub const _GLIBCXX_HAVE_FMODF: u32 = 1;
pub const _GLIBCXX_HAVE_FMODL: u32 = 1;
pub const _GLIBCXX_HAVE_FREXPF: u32 = 1;
pub const _GLIBCXX_HAVE_FREXPL: u32 = 1;
pub const _GLIBCXX_HAVE_GETENTROPY: u32 = 1;
pub const _GLIBCXX_HAVE_GETIPINFO: u32 = 1;
pub const _GLIBCXX_HAVE_GETS: u32 = 1;
pub const _GLIBCXX_HAVE_HYPOT: u32 = 1;
pub const _GLIBCXX_HAVE_HYPOTF: u32 = 1;
pub const _GLIBCXX_HAVE_HYPOTL: u32 = 1;
pub const _GLIBCXX_HAVE_ICONV: u32 = 1;
pub const _GLIBCXX_HAVE_INTTYPES_H: u32 = 1;
pub const _GLIBCXX_HAVE_ISINFF: u32 = 1;
pub const _GLIBCXX_HAVE_ISINFL: u32 = 1;
pub const _GLIBCXX_HAVE_ISNANF: u32 = 1;
pub const _GLIBCXX_HAVE_ISNANL: u32 = 1;
pub const _GLIBCXX_HAVE_ISWBLANK: u32 = 1;
pub const _GLIBCXX_HAVE_LC_MESSAGES: u32 = 1;
pub const _GLIBCXX_HAVE_LDEXPF: u32 = 1;
pub const _GLIBCXX_HAVE_LDEXPL: u32 = 1;
pub const _GLIBCXX_HAVE_LIBINTL_H: u32 = 1;
pub const _GLIBCXX_HAVE_LIMIT_AS: u32 = 1;
pub const _GLIBCXX_HAVE_LIMIT_DATA: u32 = 1;
pub const _GLIBCXX_HAVE_LIMIT_FSIZE: u32 = 1;
pub const _GLIBCXX_HAVE_LIMIT_RSS: u32 = 1;
pub const _GLIBCXX_HAVE_LIMIT_VMEM: u32 = 0;
pub const _GLIBCXX_HAVE_LINK: u32 = 1;
pub const _GLIBCXX_HAVE_LINK_H: u32 = 1;
pub const _GLIBCXX_HAVE_LINUX_FUTEX: u32 = 1;
pub const _GLIBCXX_HAVE_LINUX_RANDOM_H: u32 = 1;
pub const _GLIBCXX_HAVE_LINUX_TYPES_H: u32 = 1;
pub const _GLIBCXX_HAVE_LOCALE_H: u32 = 1;
pub const _GLIBCXX_HAVE_LOG10F: u32 = 1;
pub const _GLIBCXX_HAVE_LOG10L: u32 = 1;
pub const _GLIBCXX_HAVE_LOGF: u32 = 1;
pub const _GLIBCXX_HAVE_LOGL: u32 = 1;
pub const _GLIBCXX_HAVE_LSEEK: u32 = 1;
pub const _GLIBCXX_HAVE_MBSTATE_T: u32 = 1;
pub const _GLIBCXX_HAVE_MEMALIGN: u32 = 1;
pub const _GLIBCXX_HAVE_MEMORY_H: u32 = 1;
pub const _GLIBCXX_HAVE_MODF: u32 = 1;
pub const _GLIBCXX_HAVE_MODFF: u32 = 1;
pub const _GLIBCXX_HAVE_MODFL: u32 = 1;
pub const _GLIBCXX_HAVE_NETDB_H: u32 = 1;
pub const _GLIBCXX_HAVE_NETINET_IN_H: u32 = 1;
pub const _GLIBCXX_HAVE_NETINET_TCP_H: u32 = 1;
pub const _GLIBCXX_HAVE_OPENAT: u32 = 1;
pub const _GLIBCXX_HAVE_O_NONBLOCK: u32 = 1;
pub const _GLIBCXX_HAVE_POLL: u32 = 1;
pub const _GLIBCXX_HAVE_POLL_H: u32 = 1;
pub const _GLIBCXX_HAVE_POSIX_MEMALIGN: u32 = 1;
pub const _GLIBCXX_HAVE_POSIX_SEMAPHORE: u32 = 1;
pub const _GLIBCXX_HAVE_POWF: u32 = 1;
pub const _GLIBCXX_HAVE_POWL: u32 = 1;
pub const _GLIBCXX_HAVE_QUICK_EXIT: u32 = 1;
pub const _GLIBCXX_HAVE_READLINK: u32 = 1;
pub const _GLIBCXX_HAVE_SECURE_GETENV: u32 = 1;
pub const _GLIBCXX_HAVE_SETENV: u32 = 1;
pub const _GLIBCXX_HAVE_SINCOS: u32 = 1;
pub const _GLIBCXX_HAVE_SINCOSF: u32 = 1;
pub const _GLIBCXX_HAVE_SINCOSL: u32 = 1;
pub const _GLIBCXX_HAVE_SINF: u32 = 1;
pub const _GLIBCXX_HAVE_SINHF: u32 = 1;
pub const _GLIBCXX_HAVE_SINHL: u32 = 1;
pub const _GLIBCXX_HAVE_SINL: u32 = 1;
pub const _GLIBCXX_HAVE_SOCKATMARK: u32 = 1;
pub const _GLIBCXX_HAVE_SQRTF: u32 = 1;
pub const _GLIBCXX_HAVE_SQRTL: u32 = 1;
pub const _GLIBCXX_HAVE_STACKTRACE: u32 = 1;
pub const _GLIBCXX_HAVE_STDALIGN_H: u32 = 1;
pub const _GLIBCXX_HAVE_STDBOOL_H: u32 = 1;
pub const _GLIBCXX_HAVE_STDINT_H: u32 = 1;
pub const _GLIBCXX_HAVE_STDLIB_H: u32 = 1;
pub const _GLIBCXX_HAVE_STRERROR_L: u32 = 1;
pub const _GLIBCXX_HAVE_STRERROR_R: u32 = 1;
pub const _GLIBCXX_HAVE_STRINGS_H: u32 = 1;
pub const _GLIBCXX_HAVE_STRING_H: u32 = 1;
pub const _GLIBCXX_HAVE_STRTOF: u32 = 1;
pub const _GLIBCXX_HAVE_STRTOLD: u32 = 1;
pub const _GLIBCXX_HAVE_STRUCT_DIRENT_D_TYPE: u32 = 1;
pub const _GLIBCXX_HAVE_STRXFRM_L: u32 = 1;
pub const _GLIBCXX_HAVE_SYMLINK: u32 = 1;
pub const _GLIBCXX_HAVE_SYMVER_SYMBOL_RENAMING_RUNTIME_SUPPORT: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_IOCTL_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_IPC_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_MMAN_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_PARAM_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_RESOURCE_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_SDT_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_SEM_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_SOCKET_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_STATVFS_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_STAT_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_SYSINFO_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_TIME_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_TYPES_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_UIO_H: u32 = 1;
pub const _GLIBCXX_HAVE_S_ISREG: u32 = 1;
pub const _GLIBCXX_HAVE_TANF: u32 = 1;
pub const _GLIBCXX_HAVE_TANHF: u32 = 1;
pub const _GLIBCXX_HAVE_TANHL: u32 = 1;
pub const _GLIBCXX_HAVE_TANL: u32 = 1;
pub const _GLIBCXX_HAVE_TGMATH_H: u32 = 1;
pub const _GLIBCXX_HAVE_TIMESPEC_GET: u32 = 1;
pub const _GLIBCXX_HAVE_TLS: u32 = 1;
pub const _GLIBCXX_HAVE_TRUNCATE: u32 = 1;
pub const _GLIBCXX_HAVE_UCHAR_H: u32 = 1;
pub const _GLIBCXX_HAVE_UNISTD_H: u32 = 1;
pub const _GLIBCXX_HAVE_UNLINKAT: u32 = 1;
pub const _GLIBCXX_HAVE_USELOCALE: u32 = 1;
pub const _GLIBCXX_HAVE_UTIME_H: u32 = 1;
pub const _GLIBCXX_HAVE_VFWSCANF: u32 = 1;
pub const _GLIBCXX_HAVE_VSWSCANF: u32 = 1;
pub const _GLIBCXX_HAVE_VWSCANF: u32 = 1;
pub const _GLIBCXX_HAVE_WCHAR_H: u32 = 1;
pub const _GLIBCXX_HAVE_WCSTOF: u32 = 1;
pub const _GLIBCXX_HAVE_WCTYPE_H: u32 = 1;
pub const _GLIBCXX_HAVE_WRITEV: u32 = 1;
pub const _GLIBCXX_HAVE___CXA_THREAD_ATEXIT_IMPL: u32 = 1;
pub const _GLIBCXX_LT_OBJDIR: &[u8; 7] = b".libs/\0";
pub const _GLIBCXX_PACKAGE_BUGREPORT: &[u8; 1] = b"\0";
pub const _GLIBCXX_PACKAGE_NAME: &[u8; 15] = b"package-unused\0";
pub const _GLIBCXX_PACKAGE_STRING: &[u8; 30] = b"package-unused version-unused\0";
pub const _GLIBCXX_PACKAGE_TARNAME: &[u8; 10] = b"libstdc++\0";
pub const _GLIBCXX_PACKAGE_URL: &[u8; 1] = b"\0";
pub const _GLIBCXX_PACKAGE__GLIBCXX_VERSION: &[u8; 15] = b"version-unused\0";
pub const _GLIBCXX_STDC_HEADERS: u32 = 1;
pub const _GLIBCXX_DARWIN_USE_64_BIT_INODE: u32 = 1;
pub const _GLIBCXX11_USE_C99_COMPLEX: u32 = 1;
pub const _GLIBCXX11_USE_C99_MATH: u32 = 1;
pub const _GLIBCXX11_USE_C99_STDIO: u32 = 1;
pub const _GLIBCXX11_USE_C99_STDLIB: u32 = 1;
pub const _GLIBCXX11_USE_C99_WCHAR: u32 = 1;
pub const _GLIBCXX98_USE_C99_COMPLEX: u32 = 1;
pub const _GLIBCXX98_USE_C99_MATH: u32 = 1;
pub const _GLIBCXX98_USE_C99_STDIO: u32 = 1;
pub const _GLIBCXX98_USE_C99_STDLIB: u32 = 1;
pub const _GLIBCXX98_USE_C99_WCHAR: u32 = 1;
pub const _GLIBCXX_ATOMIC_BUILTINS: u32 = 1;
pub const _GLIBCXX_CAN_ALIGNAS_DESTRUCTIVE_SIZE: u32 = 1;
pub const _GLIBCXX_FULLY_DYNAMIC_STRING: u32 = 0;
pub const _GLIBCXX_HAS_GTHREADS: u32 = 1;
pub const _GLIBCXX_RES_LIMITS: u32 = 1;
pub const _GLIBCXX_STATIC_TZDATA: u32 = 1;
pub const _GLIBCXX_STDIO_EOF: i32 = -1;
pub const _GLIBCXX_STDIO_SEEK_CUR: u32 = 1;
pub const _GLIBCXX_STDIO_SEEK_END: u32 = 2;
pub const _GLIBCXX_SYMVER: u32 = 1;
pub const _GLIBCXX_SYMVER_GNU: u32 = 1;
pub const _GLIBCXX_USE_C11_UCHAR_CXX11: u32 = 1;
pub const _GLIBCXX_USE_C99: u32 = 1;
pub const _GLIBCXX_USE_C99_COMPLEX_ARC: u32 = 1;
pub const _GLIBCXX_USE_C99_COMPLEX_TR1: u32 = 1;
pub const _GLIBCXX_USE_C99_CTYPE: u32 = 1;
pub const _GLIBCXX_USE_C99_CTYPE_TR1: u32 = 1;
pub const _GLIBCXX_USE_C99_FENV: u32 = 1;
pub const _GLIBCXX_USE_C99_FENV_TR1: u32 = 1;
pub const _GLIBCXX_USE_C99_INTTYPES: u32 = 1;
pub const _GLIBCXX_USE_C99_INTTYPES_TR1: u32 = 1;
pub const _GLIBCXX_USE_C99_INTTYPES_WCHAR_T: u32 = 1;
pub const _GLIBCXX_USE_C99_INTTYPES_WCHAR_T_TR1: u32 = 1;
pub const _GLIBCXX_USE_C99_MATH_FUNCS: u32 = 1;
pub const _GLIBCXX_USE_C99_MATH_TR1: u32 = 1;
pub const _GLIBCXX_USE_C99_STDINT: u32 = 1;
pub const _GLIBCXX_USE_C99_STDINT_TR1: u32 = 1;
pub const _GLIBCXX_USE_CHDIR: u32 = 1;
pub const _GLIBCXX_USE_CHMOD: u32 = 1;
pub const _GLIBCXX_USE_CLOCK_MONOTONIC: u32 = 1;
pub const _GLIBCXX_USE_CLOCK_REALTIME: u32 = 1;
pub const _GLIBCXX_USE_DECIMAL_FLOAT: u32 = 1;
pub const _GLIBCXX_USE_DEV_RANDOM: u32 = 1;
pub const _GLIBCXX_USE_FCHMOD: u32 = 1;
pub const _GLIBCXX_USE_FCHMODAT: u32 = 1;
pub const _GLIBCXX_USE_FSEEKO_FTELLO: u32 = 1;
pub const _GLIBCXX_USE_GETCWD: u32 = 1;
pub const _GLIBCXX_USE_GETTIMEOFDAY: u32 = 1;
pub const _GLIBCXX_USE_GET_NPROCS: u32 = 1;
pub const _GLIBCXX_USE_INIT_PRIORITY_ATTRIBUTE: u32 = 1;
pub const _GLIBCXX_USE_LFS: u32 = 1;
pub const _GLIBCXX_USE_LONG_LONG: u32 = 1;
pub const _GLIBCXX_USE_LSTAT: u32 = 1;
pub const _GLIBCXX_USE_MKDIR: u32 = 1;
pub const _GLIBCXX_USE_NANOSLEEP: u32 = 1;
pub const _GLIBCXX_USE_NLS: u32 = 1;
pub const _GLIBCXX_USE_NL_LANGINFO_L: u32 = 1;
pub const _GLIBCXX_USE_PTHREAD_COND_CLOCKWAIT: u32 = 1;
pub const _GLIBCXX_USE_PTHREAD_RWLOCK_CLOCKLOCK: u32 = 1;
pub const _GLIBCXX_USE_PTHREAD_RWLOCK_T: u32 = 1;
pub const _GLIBCXX_USE_RANDOM_TR1: u32 = 1;
pub const _GLIBCXX_USE_REALPATH: u32 = 1;
pub const _GLIBCXX_USE_SCHED_YIELD: u32 = 1;
pub const _GLIBCXX_USE_SC_NPROCESSORS_ONLN: u32 = 1;
pub const _GLIBCXX_USE_SENDFILE: u32 = 1;
pub const _GLIBCXX_USE_ST_MTIM: u32 = 1;
pub const _GLIBCXX_USE_TMPNAM: u32 = 1;
pub const _GLIBCXX_USE_UCHAR_C8RTOMB_MBRTOC8_CXX20: u32 = 1;
pub const _GLIBCXX_USE_UCHAR_C8RTOMB_MBRTOC8_FCHAR8_T: u32 = 1;
pub const _GLIBCXX_USE_UTIME: u32 = 1;
pub const _GLIBCXX_USE_UTIMENSAT: u32 = 1;
pub const _GLIBCXX_USE_WCHAR_T: u32 = 1;
pub const _GLIBCXX_VERBOSE: u32 = 1;
pub const _GLIBCXX_ZONEINFO_DIR: &[u8; 20] = b"/usr/share/zoneinfo\0";
pub const _GTHREAD_USE_MUTEX_TIMEDLOCK: u32 = 1;
pub const __glibcxx_incomplete_container_elements: u32 = 201505;
pub const __glibcxx_uncaught_exceptions: u32 = 201411;
pub const __glibcxx_allocator_traits_is_always_equal: u32 = 201411;
pub const __glibcxx_is_null_pointer: u32 = 201309;
pub const __glibcxx_result_of_sfinae: u32 = 201210;
pub const __glibcxx_shared_ptr_arrays: u32 = 201611;
pub const __glibcxx_is_swappable: u32 = 201603;
pub const __glibcxx_void_t: u32 = 201411;
pub const __glibcxx_enable_shared_from_this: u32 = 201603;
pub const __glibcxx_math_spec_funcs: u32 = 201003;
pub const __glibcxx_exchange_function: u32 = 201304;
pub const __glibcxx_integer_sequence: u32 = 201304;
pub const __glibcxx_integral_constant_callable: u32 = 201304;
pub const __glibcxx_is_final: u32 = 201402;
pub const __glibcxx_make_reverse_iterator: u32 = 201402;
pub const __glibcxx_null_iterators: u32 = 201304;
pub const __glibcxx_transformation_trait_aliases: u32 = 201304;
pub const __glibcxx_transparent_operators: u32 = 201510;
pub const __glibcxx_tuple_element_t: u32 = 201402;
pub const __glibcxx_tuples_by_type: u32 = 201304;
pub const __glibcxx_robust_nonmodifying_seq_ops: u32 = 201304;
pub const __glibcxx_to_chars: u32 = 201611;
pub const __glibcxx_chrono_udls: u32 = 201304;
pub const __glibcxx_complex_udls: u32 = 201309;
pub const __glibcxx_generic_associative_lookup: u32 = 201304;
pub const __glibcxx_make_unique: u32 = 201304;
pub const __glibcxx_quoted_string_io: u32 = 201304;
pub const __glibcxx_shared_timed_mutex: u32 = 201402;
pub const __glibcxx_string_udls: u32 = 201304;
pub const __glibcxx_addressof_constexpr: u32 = 201603;
pub const __glibcxx_any: u32 = 201606;
pub const __glibcxx_apply: u32 = 201603;
pub const __glibcxx_as_const: u32 = 201510;
pub const __glibcxx_atomic_is_always_lock_free: u32 = 201603;
pub const __glibcxx_bool_constant: u32 = 201505;
pub const __glibcxx_byte: u32 = 201603;
pub const __cpp_lib_byte: u32 = 201603;
pub const __glibcxx_has_unique_object_representations: u32 = 201606;
pub const __glibcxx_hardware_interference_size: u32 = 201703;
pub const __glibcxx_invoke: u32 = 201411;
pub const __glibcxx_is_aggregate: u32 = 201703;
pub const __glibcxx_is_invocable: u32 = 201703;
pub const __glibcxx_launder: u32 = 201606;
pub const __glibcxx_logical_traits: u32 = 201510;
pub const __glibcxx_make_from_tuple: u32 = 201606;
pub const __glibcxx_not_fn: u32 = 201603;
pub const __glibcxx_type_trait_variable_templates: u32 = 201510;
pub const __glibcxx_variant: u32 = 202102;
pub const __glibcxx_lcm: u32 = 201606;
pub const __glibcxx_gcd: u32 = 201606;
pub const __glibcxx_gcd_lcm: u32 = 201606;
pub const __glibcxx_raw_memory_algorithms: u32 = 201606;
pub const __glibcxx_array_constexpr: u32 = 201803;
pub const __glibcxx_nonmember_container_access: u32 = 201411;
pub const __glibcxx_clamp: u32 = 201603;
pub const __glibcxx_sample: u32 = 201603;
pub const __glibcxx_boyer_moore_searcher: u32 = 201603;
pub const __glibcxx_chrono: u32 = 201611;
pub const __glibcxx_execution: u32 = 201902;
pub const __glibcxx_filesystem: u32 = 201703;
pub const __glibcxx_hypot: u32 = 201603;
pub const __glibcxx_map_try_emplace: u32 = 201411;
pub const __glibcxx_math_special_functions: u32 = 201603;
pub const __glibcxx_memory_resource: u32 = 201603;
pub const __glibcxx_node_extract: u32 = 201606;
pub const __glibcxx_parallel_algorithm: u32 = 201603;
pub const __glibcxx_scoped_lock: u32 = 201703;
pub const __glibcxx_shared_mutex: u32 = 201505;
pub const __glibcxx_shared_ptr_weak_type: u32 = 201606;
pub const __glibcxx_string_view: u32 = 201803;
pub const __glibcxx_unordered_map_try_emplace: u32 = 201411;
pub const __glibcxx_optional: u32 = 201606;
pub const __glibcxx_constexpr_char_traits: u32 = 201611;
pub const __glibcxx_constexpr_string: u32 = 201611;
pub const _GLIBCXX_CSTDINT: u32 = 1;
pub const _STDINT_H: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 1;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 1;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C23: u32 = 1;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 1;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 1;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C23: u32 = 1;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const _BITS_STDINT_LEAST_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const INT8_WIDTH: u32 = 8;
pub const UINT8_WIDTH: u32 = 8;
pub const INT16_WIDTH: u32 = 16;
pub const UINT16_WIDTH: u32 = 16;
pub const INT32_WIDTH: u32 = 32;
pub const UINT32_WIDTH: u32 = 32;
pub const INT64_WIDTH: u32 = 64;
pub const UINT64_WIDTH: u32 = 64;
pub const INT_LEAST8_WIDTH: u32 = 8;
pub const UINT_LEAST8_WIDTH: u32 = 8;
pub const INT_LEAST16_WIDTH: u32 = 16;
pub const UINT_LEAST16_WIDTH: u32 = 16;
pub const INT_LEAST32_WIDTH: u32 = 32;
pub const UINT_LEAST32_WIDTH: u32 = 32;
pub const INT_LEAST64_WIDTH: u32 = 64;
pub const UINT_LEAST64_WIDTH: u32 = 64;
pub const INT_FAST8_WIDTH: u32 = 8;
pub const UINT_FAST8_WIDTH: u32 = 8;
pub const INT_FAST16_WIDTH: u32 = 64;
pub const UINT_FAST16_WIDTH: u32 = 64;
pub const INT_FAST32_WIDTH: u32 = 64;
pub const UINT_FAST32_WIDTH: u32 = 64;
pub const INT_FAST64_WIDTH: u32 = 64;
pub const UINT_FAST64_WIDTH: u32 = 64;
pub const INTPTR_WIDTH: u32 = 64;
pub const UINTPTR_WIDTH: u32 = 64;
pub const INTMAX_WIDTH: u32 = 64;
pub const UINTMAX_WIDTH: u32 = 64;
pub const PTRDIFF_WIDTH: u32 = 64;
pub const SIG_ATOMIC_WIDTH: u32 = 32;
pub const SIZE_WIDTH: u32 = 64;
pub const WCHAR_WIDTH: u32 = 32;
pub const WINT_WIDTH: u32 = 32;
pub type std_nullptr_t = *const ::core::ffi::c_void;
unsafe extern "C" {
    #[link_name = "\u{1}_ZSt21__glibcxx_assert_failPKciS0_S0_"]
    pub fn std___glibcxx_assert_fail(
        __file: *const ::core::ffi::c_char,
        __line: ::core::ffi::c_int,
        __function: *const ::core::ffi::c_char,
        __condition: *const ::core::ffi::c_char,
    ) -> !;
}
pub type std_byte = ::core::ffi::c_uchar;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct std___byte_operand {
    pub _address: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std___byte_operand_open0_bool__close0"]
        [::core::mem::size_of::<std___byte_operand>() - 1usize];
    ["Align of template specialization: std___byte_operand_open0_bool__close0"]
        [::core::mem::align_of::<std___byte_operand>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std___byte_operand_open0_char_close0"]
        [::core::mem::size_of::<std___byte_operand>() - 1usize];
    ["Align of template specialization: std___byte_operand_open0_char_close0"]
        [::core::mem::align_of::<std___byte_operand>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std___byte_operand_open0_signed_char_close0"]
        [::core::mem::size_of::<std___byte_operand>() - 1usize];
    ["Align of template specialization: std___byte_operand_open0_signed_char_close0"]
        [::core::mem::align_of::<std___byte_operand>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std___byte_operand_open0_unsigned_char_close0"]
        [::core::mem::size_of::<std___byte_operand>() - 1usize];
    ["Align of template specialization: std___byte_operand_open0_unsigned_char_close0"]
        [::core::mem::align_of::<std___byte_operand>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std___byte_operand_open0_wchar_t_close0"]
        [::core::mem::size_of::<std___byte_operand>() - 1usize];
    ["Align of template specialization: std___byte_operand_open0_wchar_t_close0"]
        [::core::mem::align_of::<std___byte_operand>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std___byte_operand_open0_char16_t_close0"]
        [::core::mem::size_of::<std___byte_operand>() - 1usize];
    ["Align of template specialization: std___byte_operand_open0_char16_t_close0"]
        [::core::mem::align_of::<std___byte_operand>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std___byte_operand_open0_char32_t_close0"]
        [::core::mem::size_of::<std___byte_operand>() - 1usize];
    ["Align of template specialization: std___byte_operand_open0_char32_t_close0"]
        [::core::mem::align_of::<std___byte_operand>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std___byte_operand_open0_short_close0"]
        [::core::mem::size_of::<std___byte_operand>() - 1usize];
    ["Align of template specialization: std___byte_operand_open0_short_close0"]
        [::core::mem::align_of::<std___byte_operand>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std___byte_operand_open0_unsigned_short_close0"]
        [::core::mem::size_of::<std___byte_operand>() - 1usize];
    ["Align of template specialization: std___byte_operand_open0_unsigned_short_close0"]
        [::core::mem::align_of::<std___byte_operand>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std___byte_operand_open0_int_close0"]
        [::core::mem::size_of::<std___byte_operand>() - 1usize];
    ["Align of template specialization: std___byte_operand_open0_int_close0"]
        [::core::mem::align_of::<std___byte_operand>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std___byte_operand_open0_unsigned_int_close0"]
        [::core::mem::size_of::<std___byte_operand>() - 1usize];
    ["Align of template specialization: std___byte_operand_open0_unsigned_int_close0"]
        [::core::mem::align_of::<std___byte_operand>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std___byte_operand_open0_long_close0"]
        [::core::mem::size_of::<std___byte_operand>() - 1usize];
    ["Align of template specialization: std___byte_operand_open0_long_close0"]
        [::core::mem::align_of::<std___byte_operand>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std___byte_operand_open0_unsigned_long_close0"]
        [::core::mem::size_of::<std___byte_operand>() - 1usize];
    ["Align of template specialization: std___byte_operand_open0_unsigned_long_close0"]
        [::core::mem::align_of::<std___byte_operand>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std___byte_operand_open0_long_long_close0"]
        [::core::mem::size_of::<std___byte_operand>() - 1usize];
    ["Align of template specialization: std___byte_operand_open0_long_long_close0"]
        [::core::mem::align_of::<std___byte_operand>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std___byte_operand_open0_unsigned_long_long_close0"]
        [::core::mem::size_of::<std___byte_operand>() - 1usize];
    ["Align of template specialization: std___byte_operand_open0_unsigned_long_long_close0"]
        [::core::mem::align_of::<std___byte_operand>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std___byte_operand_open0___int128_close0"]
        [::core::mem::size_of::<std___byte_operand>() - 1usize];
    ["Align of template specialization: std___byte_operand_open0___int128_close0"]
        [::core::mem::align_of::<std___byte_operand>() - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of template specialization: std___byte_operand_open0_unsigned___int128_close0"]
        [::core::mem::size_of::<std___byte_operand>() - 1usize];
    ["Align of template specialization: std___byte_operand_open0_unsigned___int128_close0"]
        [::core::mem::align_of::<std___byte_operand>() - 1usize];
};
pub type std___byte_op_t = std___byte_operand;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::core::ffi::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of max_align_t"][::core::mem::size_of::<max_align_t>() - 32usize];
    ["Alignment of max_align_t"][::core::mem::align_of::<max_align_t>() - 16usize];
    ["Offset of field: max_align_t::__clang_max_align_nonce1"]
        [::core::mem::offset_of!(max_align_t, __clang_max_align_nonce1) - 0usize];
    ["Offset of field: max_align_t::__clang_max_align_nonce2"]
        [::core::mem::offset_of!(max_align_t, __clang_max_align_nonce2) - 16usize];
};
pub type __u_char = ::core::ffi::c_uchar;
pub type __u_short = ::core::ffi::c_ushort;
pub type __u_int = ::core::ffi::c_uint;
pub type __u_long = ::core::ffi::c_ulong;
pub type __int8_t = ::core::ffi::c_schar;
pub type __uint8_t = ::core::ffi::c_uchar;
pub type __int16_t = ::core::ffi::c_short;
pub type __uint16_t = ::core::ffi::c_ushort;
pub type __int32_t = ::core::ffi::c_int;
pub type __uint32_t = ::core::ffi::c_uint;
pub type __int64_t = ::core::ffi::c_long;
pub type __uint64_t = ::core::ffi::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::core::ffi::c_long;
pub type __u_quad_t = ::core::ffi::c_ulong;
pub type __intmax_t = ::core::ffi::c_long;
pub type __uintmax_t = ::core::ffi::c_ulong;
pub type __dev_t = ::core::ffi::c_ulong;
pub type __uid_t = ::core::ffi::c_uint;
pub type __gid_t = ::core::ffi::c_uint;
pub type __ino_t = ::core::ffi::c_ulong;
pub type __ino64_t = ::core::ffi::c_ulong;
pub type __mode_t = ::core::ffi::c_uint;
pub type __nlink_t = ::core::ffi::c_uint;
pub type __off_t = ::core::ffi::c_long;
pub type __off64_t = ::core::ffi::c_long;
pub type __pid_t = ::core::ffi::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct __fsid_t {
    pub __val: [::core::ffi::c_int; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __fsid_t"][::core::mem::size_of::<__fsid_t>() - 8usize];
    ["Alignment of __fsid_t"][::core::mem::align_of::<__fsid_t>() - 4usize];
    ["Offset of field: __fsid_t::__val"][::core::mem::offset_of!(__fsid_t, __val) - 0usize];
};
pub type __clock_t = ::core::ffi::c_long;
pub type __rlim_t = ::core::ffi::c_ulong;
pub type __rlim64_t = ::core::ffi::c_ulong;
pub type __id_t = ::core::ffi::c_uint;
pub type __time_t = ::core::ffi::c_long;
pub type __useconds_t = ::core::ffi::c_uint;
pub type __suseconds_t = ::core::ffi::c_long;
pub type __suseconds64_t = ::core::ffi::c_long;
pub type __daddr_t = ::core::ffi::c_int;
pub type __key_t = ::core::ffi::c_int;
pub type __clockid_t = ::core::ffi::c_int;
pub type __timer_t = *mut ::core::ffi::c_void;
pub type __blksize_t = ::core::ffi::c_int;
pub type __blkcnt_t = ::core::ffi::c_long;
pub type __blkcnt64_t = ::core::ffi::c_long;
pub type __fsblkcnt_t = ::core::ffi::c_ulong;
pub type __fsblkcnt64_t = ::core::ffi::c_ulong;
pub type __fsfilcnt_t = ::core::ffi::c_ulong;
pub type __fsfilcnt64_t = ::core::ffi::c_ulong;
pub type __fsword_t = ::core::ffi::c_long;
pub type __ssize_t = ::core::ffi::c_long;
pub type __syscall_slong_t = ::core::ffi::c_long;
pub type __syscall_ulong_t = ::core::ffi::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::core::ffi::c_char;
pub type __intptr_t = ::core::ffi::c_long;
pub type __socklen_t = ::core::ffi::c_uint;
pub type __sig_atomic_t = ::core::ffi::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::core::ffi::c_schar;
pub type int_fast16_t = ::core::ffi::c_long;
pub type int_fast32_t = ::core::ffi::c_long;
pub type int_fast64_t = ::core::ffi::c_long;
pub type uint_fast8_t = ::core::ffi::c_uchar;
pub type uint_fast16_t = ::core::ffi::c_ulong;
pub type uint_fast32_t = ::core::ffi::c_ulong;
pub type uint_fast64_t = ::core::ffi::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
#[doc = " @brief An opaque structure; see astcenc_internal.h for definition."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct astcenc_context {
    _unused: [u8; 0],
}
#[doc = " @brief The call was successful."]
pub const astcenc_error_ASTCENC_SUCCESS: astcenc_error = 0;
#[doc = " @brief The call failed due to low memory, or undersized I/O buffers."]
pub const astcenc_error_ASTCENC_ERR_OUT_OF_MEM: astcenc_error = 1;
#[doc = " @brief The call failed due to the build using fast math."]
pub const astcenc_error_ASTCENC_ERR_BAD_CPU_FLOAT: astcenc_error = 2;
#[doc = " @brief The call failed due to an out-of-spec parameter."]
pub const astcenc_error_ASTCENC_ERR_BAD_PARAM: astcenc_error = 3;
#[doc = " @brief The call failed due to an out-of-spec block size."]
pub const astcenc_error_ASTCENC_ERR_BAD_BLOCK_SIZE: astcenc_error = 4;
#[doc = " @brief The call failed due to an out-of-spec color profile."]
pub const astcenc_error_ASTCENC_ERR_BAD_PROFILE: astcenc_error = 5;
#[doc = " @brief The call failed due to an out-of-spec quality value."]
pub const astcenc_error_ASTCENC_ERR_BAD_QUALITY: astcenc_error = 6;
#[doc = " @brief The call failed due to an out-of-spec component swizzle."]
pub const astcenc_error_ASTCENC_ERR_BAD_SWIZZLE: astcenc_error = 7;
#[doc = " @brief The call failed due to an out-of-spec flag set."]
pub const astcenc_error_ASTCENC_ERR_BAD_FLAGS: astcenc_error = 8;
#[doc = " @brief The call failed due to the context not supporting the operation."]
pub const astcenc_error_ASTCENC_ERR_BAD_CONTEXT: astcenc_error = 9;
#[doc = " @brief The call failed due to unimplemented functionality."]
pub const astcenc_error_ASTCENC_ERR_NOT_IMPLEMENTED: astcenc_error = 10;
#[doc = " @brief The call failed due to an out-of-spec decode mode flag set."]
pub const astcenc_error_ASTCENC_ERR_BAD_DECODE_MODE: astcenc_error = 11;
#[doc = " @brief A codec API error code."]
pub type astcenc_error = ::core::ffi::c_uint;
#[doc = " @brief The LDR sRGB color profile."]
pub const astcenc_profile_ASTCENC_PRF_LDR_SRGB: astcenc_profile = 0;
#[doc = " @brief The LDR linear color profile."]
pub const astcenc_profile_ASTCENC_PRF_LDR: astcenc_profile = 1;
#[doc = " @brief The HDR RGB with LDR alpha color profile."]
pub const astcenc_profile_ASTCENC_PRF_HDR_RGB_LDR_A: astcenc_profile = 2;
#[doc = " @brief The HDR RGBA color profile."]
pub const astcenc_profile_ASTCENC_PRF_HDR: astcenc_profile = 3;
#[doc = " @brief A codec color profile."]
pub type astcenc_profile = ::core::ffi::c_uint;
#[doc = " @brief The fastest, lowest quality, search preset."]
pub const ASTCENC_PRE_FASTEST: f32 = 0.0;
#[doc = " @brief The fast search preset."]
pub const ASTCENC_PRE_FAST: f32 = 10.0;
#[doc = " @brief The medium quality search preset."]
pub const ASTCENC_PRE_MEDIUM: f32 = 60.0;
#[doc = " @brief The thorough quality search preset."]
pub const ASTCENC_PRE_THOROUGH: f32 = 98.0;
#[doc = " @brief The thorough quality search preset."]
pub const ASTCENC_PRE_VERYTHOROUGH: f32 = 99.0;
#[doc = " @brief The exhaustive, highest quality, search preset."]
pub const ASTCENC_PRE_EXHAUSTIVE: f32 = 100.0;
#[doc = " @brief Select the red component."]
pub const astcenc_swz_ASTCENC_SWZ_R: astcenc_swz = 0;
#[doc = " @brief Select the green component."]
pub const astcenc_swz_ASTCENC_SWZ_G: astcenc_swz = 1;
#[doc = " @brief Select the blue component."]
pub const astcenc_swz_ASTCENC_SWZ_B: astcenc_swz = 2;
#[doc = " @brief Select the alpha component."]
pub const astcenc_swz_ASTCENC_SWZ_A: astcenc_swz = 3;
#[doc = " @brief Use a constant zero component."]
pub const astcenc_swz_ASTCENC_SWZ_0: astcenc_swz = 4;
#[doc = " @brief Use a constant one component."]
pub const astcenc_swz_ASTCENC_SWZ_1: astcenc_swz = 5;
#[doc = " @brief Use a reconstructed normal vector Z component."]
pub const astcenc_swz_ASTCENC_SWZ_Z: astcenc_swz = 6;
#[doc = " @brief A codec component swizzle selector."]
pub type astcenc_swz = ::core::ffi::c_uint;
#[doc = " @brief A texel component swizzle."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct astcenc_swizzle {
    #[doc = " @brief The red component selector."]
    pub r: astcenc_swz,
    #[doc = " @brief The green component selector."]
    pub g: astcenc_swz,
    #[doc = " @brief The blue component selector."]
    pub b: astcenc_swz,
    #[doc = " @brief The alpha component selector."]
    pub a: astcenc_swz,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of astcenc_swizzle"][::core::mem::size_of::<astcenc_swizzle>() - 16usize];
    ["Alignment of astcenc_swizzle"][::core::mem::align_of::<astcenc_swizzle>() - 4usize];
    ["Offset of field: astcenc_swizzle::r"][::core::mem::offset_of!(astcenc_swizzle, r) - 0usize];
    ["Offset of field: astcenc_swizzle::g"][::core::mem::offset_of!(astcenc_swizzle, g) - 4usize];
    ["Offset of field: astcenc_swizzle::b"][::core::mem::offset_of!(astcenc_swizzle, b) - 8usize];
    ["Offset of field: astcenc_swizzle::a"][::core::mem::offset_of!(astcenc_swizzle, a) - 12usize];
};
#[doc = " @brief Unorm 8-bit data per component."]
pub const astcenc_type_ASTCENC_TYPE_U8: astcenc_type = 0;
#[doc = " @brief 16-bit float per component."]
pub const astcenc_type_ASTCENC_TYPE_F16: astcenc_type = 1;
#[doc = " @brief 32-bit float per component."]
pub const astcenc_type_ASTCENC_TYPE_F32: astcenc_type = 2;
#[doc = " @brief A texel component data format."]
pub type astcenc_type = ::core::ffi::c_uint;
#[doc = " @brief Function pointer type for compression progress reporting callback."]
pub type astcenc_progress_callback = ::core::option::Option<unsafe extern "C" fn(arg1: f32)>;
#[doc = " @brief Enable normal map compression.\n\n Input data will be treated a two component normal map, storing X and Y, and the codec will\n optimize for angular error rather than simple linear PSNR. In this mode the input swizzle should\n be e.g. rrrg (the default ordering for ASTC normals on the command line) or gggr (the ordering\n used by BC5n)."]
pub const ASTCENC_FLG_MAP_NORMAL: ::core::ffi::c_uint = 1;
#[doc = " @brief Enable compression heuristics that assume use of decode_unorm8 decode mode.\n\n The decode_unorm8 decode mode rounds differently to the decode_fp16 decode mode, so enabling this\n flag during compression will allow the compressor to use the correct rounding when selecting\n encodings. This will improve the compressed image quality if your application is using the\n decode_unorm8 decode mode, but will reduce image quality if using decode_fp16.\n\n Note that LDR_SRGB images will always use decode_unorm8 for the RGB channels, irrespective of\n this setting."]
pub const ASTCENC_FLG_USE_DECODE_UNORM8: ::core::ffi::c_uint = 2;
#[doc = " @brief Enable alpha weighting.\n\n The input alpha value is used for transparency, so errors in the RGB components are weighted by\n the transparency level. This allows the codec to more accurately encode the alpha value in areas\n where the color value is less significant."]
pub const ASTCENC_FLG_USE_ALPHA_WEIGHT: ::core::ffi::c_uint = 4;
#[doc = " @brief Enable perceptual error metrics.\n\n This mode enables perceptual compression mode, which will optimize for perceptual error rather\n than best PSNR. Only some input modes support perceptual error metrics."]
pub const ASTCENC_FLG_USE_PERCEPTUAL: ::core::ffi::c_uint = 8;
#[doc = " @brief Create a decompression-only context.\n\n This mode disables support for compression. This enables context allocation to skip some\n transient buffer allocation, resulting in lower memory usage."]
pub const ASTCENC_FLG_DECOMPRESS_ONLY: ::core::ffi::c_uint = 16;
#[doc = " @brief Create a self-decompression context.\n\n This mode configures the compressor so that it is only guaranteed to be able to decompress images\n that were actually created using the current context. This is the common case for compression use\n cases, and setting this flag enables additional optimizations, but does mean that the context\n cannot reliably decompress arbitrary ASTC images."]
pub const ASTCENC_FLG_SELF_DECOMPRESS_ONLY: ::core::ffi::c_uint = 32;
#[doc = " @brief Enable RGBM map compression.\n\n Input data will be treated as HDR data that has been stored in an LDR RGBM-encoded wrapper\n format. Data must be preprocessed by the user to be in LDR RGBM format before calling the\n compression function, this flag is only used to control the use of RGBM-specific heuristics and\n error metrics.\n\n IMPORTANT: The ASTC format is prone to bad failure modes with unconstrained RGBM data; very small\n M values can round to zero due to quantization and result in black or white pixels. It is highly\n recommended that the minimum value of M used in the encoding is kept above a lower threshold (try\n 16 or 32). Applying this threshold reduces the number of very dark colors that can be\n represented, but is still higher precision than 8-bit LDR.\n\n When this flag is set the value of @c rgbm_m_scale in the context must be set to the RGBM scale\n factor used during reconstruction. This defaults to 5 when in RGBM mode.\n\n It is recommended that the value of @c cw_a_weight is set to twice the value of the multiplier\n scale, ensuring that the M value is accurately encoded. This defaults to 10 when in RGBM mode,\n matching the default scale factor."]
pub const ASTCENC_FLG_MAP_RGBM: ::core::ffi::c_uint = 64;
#[doc = " @brief The bit mask of all valid flags."]
pub const ASTCENC_ALL_FLAGS: ::core::ffi::c_uint = 127;
#[doc = " @brief The config structure.\n\n This structure will initially be populated by a call to astcenc_config_init, but power users may\n modify it before calling astcenc_context_alloc. See astcenccli_toplevel_help.cpp for full user\n documentation of the power-user settings.\n\n Note for any settings which are associated with a specific color component, the value in the\n config applies to the component that exists after any compression data swizzle is applied."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct astcenc_config {
    #[doc = " @brief The color profile."]
    pub profile: astcenc_profile,
    #[doc = " @brief The set of set flags."]
    pub flags: ::core::ffi::c_uint,
    #[doc = " @brief The ASTC block size X dimension."]
    pub block_x: ::core::ffi::c_uint,
    #[doc = " @brief The ASTC block size Y dimension."]
    pub block_y: ::core::ffi::c_uint,
    #[doc = " @brief The ASTC block size Z dimension."]
    pub block_z: ::core::ffi::c_uint,
    #[doc = " @brief The red component weight scale for error weighting (-cw)."]
    pub cw_r_weight: f32,
    #[doc = " @brief The green component weight scale for error weighting (-cw)."]
    pub cw_g_weight: f32,
    #[doc = " @brief The blue component weight scale for error weighting (-cw)."]
    pub cw_b_weight: f32,
    #[doc = " @brief The alpha component weight scale for error weighting (-cw)."]
    pub cw_a_weight: f32,
    #[doc = " @brief The radius for any alpha-weight scaling (-a).\n\n It is recommended that this is set to 1 when using FLG_USE_ALPHA_WEIGHT on a texture that\n will be sampled using linear texture filtering to minimize color bleed out of transparent\n texels that are adjacent to non-transparent texels."]
    pub a_scale_radius: ::core::ffi::c_uint,
    #[doc = " @brief The RGBM scale factor for the shared multiplier (-rgbm)."]
    pub rgbm_m_scale: f32,
    #[doc = " @brief The maximum number of partitions searched (-partitioncountlimit).\n\n Valid values are between 1 and 4."]
    pub tune_partition_count_limit: ::core::ffi::c_uint,
    #[doc = " @brief The maximum number of partitions searched (-2partitionindexlimit).\n\n Valid values are between 1 and 1024."]
    pub tune_2partition_index_limit: ::core::ffi::c_uint,
    #[doc = " @brief The maximum number of partitions searched (-3partitionindexlimit).\n\n Valid values are between 1 and 1024."]
    pub tune_3partition_index_limit: ::core::ffi::c_uint,
    #[doc = " @brief The maximum number of partitions searched (-4partitionindexlimit).\n\n Valid values are between 1 and 1024."]
    pub tune_4partition_index_limit: ::core::ffi::c_uint,
    #[doc = " @brief The maximum centile for block modes searched (-blockmodelimit).\n\n Valid values are between 1 and 100."]
    pub tune_block_mode_limit: ::core::ffi::c_uint,
    #[doc = " @brief The maximum iterative refinements applied (-refinementlimit).\n\n Valid values are between 1 and N; there is no technical upper limit\n but little benefit is expected after N=4."]
    pub tune_refinement_limit: ::core::ffi::c_uint,
    #[doc = " @brief The number of trial candidates per mode search (-candidatelimit).\n\n Valid values are between 1 and TUNE_MAX_TRIAL_CANDIDATES."]
    pub tune_candidate_limit: ::core::ffi::c_uint,
    #[doc = " @brief The number of trial partitionings per search (-2partitioncandidatelimit).\n\n Valid values are between 1 and TUNE_MAX_PARTITIONING_CANDIDATES."]
    pub tune_2partitioning_candidate_limit: ::core::ffi::c_uint,
    #[doc = " @brief The number of trial partitionings per search (-3partitioncandidatelimit).\n\n Valid values are between 1 and TUNE_MAX_PARTITIONING_CANDIDATES."]
    pub tune_3partitioning_candidate_limit: ::core::ffi::c_uint,
    #[doc = " @brief The number of trial partitionings per search (-4partitioncandidatelimit).\n\n Valid values are between 1 and TUNE_MAX_PARTITIONING_CANDIDATES."]
    pub tune_4partitioning_candidate_limit: ::core::ffi::c_uint,
    #[doc = " @brief The dB threshold for stopping block search (-dblimit).\n\n This option is ineffective for HDR textures."]
    pub tune_db_limit: f32,
    #[doc = " @brief The amount of MSE overshoot needed to early-out trials.\n\n The first early-out is for 1 partition, 1 plane trials, where we try a minimal encode using\n the high probability block modes. This can short-cut compression for simple blocks.\n\n The second early-out is for refinement trials, where we can exit refinement once quality is\n reached."]
    pub tune_mse_overshoot: f32,
    #[doc = " @brief The threshold for skipping 3.1/4.1 trials (-2partitionlimitfactor).\n\n This option is further scaled for normal maps, so it skips less often."]
    pub tune_2partition_early_out_limit_factor: f32,
    #[doc = " @brief The threshold for skipping 4.1 trials (-3partitionlimitfactor).\n\n This option is further scaled for normal maps, so it skips less often."]
    pub tune_3partition_early_out_limit_factor: f32,
    #[doc = " @brief The threshold for skipping two weight planes (-2planelimitcorrelation).\n\n This option is ineffective for normal maps."]
    pub tune_2plane_early_out_limit_correlation: f32,
    #[doc = " @brief The config enable for the mode0 fast-path search.\n\n If this is set to TUNE_MIN_TEXELS_MODE0 or higher then the early-out fast mode0\n search is enabled. This option is ineffective for 3D block sizes."]
    pub tune_search_mode0_enable: f32,
    #[doc = " @brief The progress callback, can be @c nullptr.\n\n If this is specified the codec will peridocially report progress for\n compression as a percentage between 0 and 100. The callback is called from one\n of the compressor threads, so doing significant work in the callback will\n reduce compression performance."]
    pub progress_callback: astcenc_progress_callback,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of astcenc_config"][::core::mem::size_of::<astcenc_config>() - 120usize];
    ["Alignment of astcenc_config"][::core::mem::align_of::<astcenc_config>() - 8usize];
    ["Offset of field: astcenc_config::profile"]
        [::core::mem::offset_of!(astcenc_config, profile) - 0usize];
    ["Offset of field: astcenc_config::flags"]
        [::core::mem::offset_of!(astcenc_config, flags) - 4usize];
    ["Offset of field: astcenc_config::block_x"]
        [::core::mem::offset_of!(astcenc_config, block_x) - 8usize];
    ["Offset of field: astcenc_config::block_y"]
        [::core::mem::offset_of!(astcenc_config, block_y) - 12usize];
    ["Offset of field: astcenc_config::block_z"]
        [::core::mem::offset_of!(astcenc_config, block_z) - 16usize];
    ["Offset of field: astcenc_config::cw_r_weight"]
        [::core::mem::offset_of!(astcenc_config, cw_r_weight) - 20usize];
    ["Offset of field: astcenc_config::cw_g_weight"]
        [::core::mem::offset_of!(astcenc_config, cw_g_weight) - 24usize];
    ["Offset of field: astcenc_config::cw_b_weight"]
        [::core::mem::offset_of!(astcenc_config, cw_b_weight) - 28usize];
    ["Offset of field: astcenc_config::cw_a_weight"]
        [::core::mem::offset_of!(astcenc_config, cw_a_weight) - 32usize];
    ["Offset of field: astcenc_config::a_scale_radius"]
        [::core::mem::offset_of!(astcenc_config, a_scale_radius) - 36usize];
    ["Offset of field: astcenc_config::rgbm_m_scale"]
        [::core::mem::offset_of!(astcenc_config, rgbm_m_scale) - 40usize];
    ["Offset of field: astcenc_config::tune_partition_count_limit"]
        [::core::mem::offset_of!(astcenc_config, tune_partition_count_limit) - 44usize];
    ["Offset of field: astcenc_config::tune_2partition_index_limit"]
        [::core::mem::offset_of!(astcenc_config, tune_2partition_index_limit) - 48usize];
    ["Offset of field: astcenc_config::tune_3partition_index_limit"]
        [::core::mem::offset_of!(astcenc_config, tune_3partition_index_limit) - 52usize];
    ["Offset of field: astcenc_config::tune_4partition_index_limit"]
        [::core::mem::offset_of!(astcenc_config, tune_4partition_index_limit) - 56usize];
    ["Offset of field: astcenc_config::tune_block_mode_limit"]
        [::core::mem::offset_of!(astcenc_config, tune_block_mode_limit) - 60usize];
    ["Offset of field: astcenc_config::tune_refinement_limit"]
        [::core::mem::offset_of!(astcenc_config, tune_refinement_limit) - 64usize];
    ["Offset of field: astcenc_config::tune_candidate_limit"]
        [::core::mem::offset_of!(astcenc_config, tune_candidate_limit) - 68usize];
    ["Offset of field: astcenc_config::tune_2partitioning_candidate_limit"]
        [::core::mem::offset_of!(astcenc_config, tune_2partitioning_candidate_limit) - 72usize];
    ["Offset of field: astcenc_config::tune_3partitioning_candidate_limit"]
        [::core::mem::offset_of!(astcenc_config, tune_3partitioning_candidate_limit) - 76usize];
    ["Offset of field: astcenc_config::tune_4partitioning_candidate_limit"]
        [::core::mem::offset_of!(astcenc_config, tune_4partitioning_candidate_limit) - 80usize];
    ["Offset of field: astcenc_config::tune_db_limit"]
        [::core::mem::offset_of!(astcenc_config, tune_db_limit) - 84usize];
    ["Offset of field: astcenc_config::tune_mse_overshoot"]
        [::core::mem::offset_of!(astcenc_config, tune_mse_overshoot) - 88usize];
    ["Offset of field: astcenc_config::tune_2partition_early_out_limit_factor"]
        [::core::mem::offset_of!(astcenc_config, tune_2partition_early_out_limit_factor) - 92usize];
    ["Offset of field: astcenc_config::tune_3partition_early_out_limit_factor"]
        [::core::mem::offset_of!(astcenc_config, tune_3partition_early_out_limit_factor) - 96usize];
    ["Offset of field: astcenc_config::tune_2plane_early_out_limit_correlation"][::core::mem::offset_of!(
        astcenc_config,
        tune_2plane_early_out_limit_correlation
    ) - 100usize];
    ["Offset of field: astcenc_config::tune_search_mode0_enable"]
        [::core::mem::offset_of!(astcenc_config, tune_search_mode0_enable) - 104usize];
    ["Offset of field: astcenc_config::progress_callback"]
        [::core::mem::offset_of!(astcenc_config, progress_callback) - 112usize];
};
#[doc = " @brief An uncompressed 2D or 3D image.\n\n 3D image are passed in as an array of 2D slices. Each slice has identical\n size and color format."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct astcenc_image {
    #[doc = " @brief The X dimension of the image, in texels."]
    pub dim_x: ::core::ffi::c_uint,
    #[doc = " @brief The Y dimension of the image, in texels."]
    pub dim_y: ::core::ffi::c_uint,
    #[doc = " @brief The Z dimension of the image, in texels."]
    pub dim_z: ::core::ffi::c_uint,
    #[doc = " @brief The data type per component."]
    pub data_type: astcenc_type,
    #[doc = " @brief The array of 2D slices, of length @c dim_z."]
    pub data: *mut *mut ::core::ffi::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of astcenc_image"][::core::mem::size_of::<astcenc_image>() - 24usize];
    ["Alignment of astcenc_image"][::core::mem::align_of::<astcenc_image>() - 8usize];
    ["Offset of field: astcenc_image::dim_x"]
        [::core::mem::offset_of!(astcenc_image, dim_x) - 0usize];
    ["Offset of field: astcenc_image::dim_y"]
        [::core::mem::offset_of!(astcenc_image, dim_y) - 4usize];
    ["Offset of field: astcenc_image::dim_z"]
        [::core::mem::offset_of!(astcenc_image, dim_z) - 8usize];
    ["Offset of field: astcenc_image::data_type"]
        [::core::mem::offset_of!(astcenc_image, data_type) - 12usize];
    ["Offset of field: astcenc_image::data"]
        [::core::mem::offset_of!(astcenc_image, data) - 16usize];
};
#[doc = " @brief A block encoding metadata query result.\n\n If the block is an error block or a constant color block or an error block all fields other than\n the profile, block dimensions, and error/constant indicator will be zero."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct astcenc_block_info {
    #[doc = " @brief The block encoding color profile."]
    pub profile: astcenc_profile,
    #[doc = " @brief The number of texels in the X dimension."]
    pub block_x: ::core::ffi::c_uint,
    #[doc = " @brief The number of texels in the Y dimension."]
    pub block_y: ::core::ffi::c_uint,
    #[doc = " @brief The number of texel in the Z dimension."]
    pub block_z: ::core::ffi::c_uint,
    #[doc = " @brief The number of texels in the block."]
    pub texel_count: ::core::ffi::c_uint,
    #[doc = " @brief True if this block is an error block."]
    pub is_error_block: bool,
    #[doc = " @brief True if this block is a constant color block."]
    pub is_constant_block: bool,
    #[doc = " @brief True if this block is an HDR block."]
    pub is_hdr_block: bool,
    #[doc = " @brief True if this block uses two weight planes."]
    pub is_dual_plane_block: bool,
    #[doc = " @brief The number of partitions if not constant color."]
    pub partition_count: ::core::ffi::c_uint,
    #[doc = " @brief The partition index if 2 - 4 partitions used."]
    pub partition_index: ::core::ffi::c_uint,
    #[doc = " @brief The component index of the second plane if dual plane."]
    pub dual_plane_component: ::core::ffi::c_uint,
    #[doc = " @brief The color endpoint encoding mode for each partition."]
    pub color_endpoint_modes: [::core::ffi::c_uint; 4usize],
    #[doc = " @brief The number of color endpoint quantization levels."]
    pub color_level_count: ::core::ffi::c_uint,
    #[doc = " @brief The number of weight quantization levels."]
    pub weight_level_count: ::core::ffi::c_uint,
    #[doc = " @brief The number of weights in the X dimension."]
    pub weight_x: ::core::ffi::c_uint,
    #[doc = " @brief The number of weights in the Y dimension."]
    pub weight_y: ::core::ffi::c_uint,
    #[doc = " @brief The number of weights in the Z dimension."]
    pub weight_z: ::core::ffi::c_uint,
    #[doc = " @brief The unpacked color endpoints for each partition."]
    pub color_endpoints: [[[f32; 4usize]; 2usize]; 4usize],
    #[doc = " @brief The per-texel interpolation weights for the block."]
    pub weight_values_plane1: [f32; 216usize],
    #[doc = " @brief The per-texel interpolation weights for the block."]
    pub weight_values_plane2: [f32; 216usize],
    #[doc = " @brief The per-texel partition assignments for the block."]
    pub partition_assignment: [u8; 216usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of astcenc_block_info"][::core::mem::size_of::<astcenc_block_info>() - 2144usize];
    ["Alignment of astcenc_block_info"][::core::mem::align_of::<astcenc_block_info>() - 4usize];
    ["Offset of field: astcenc_block_info::profile"]
        [::core::mem::offset_of!(astcenc_block_info, profile) - 0usize];
    ["Offset of field: astcenc_block_info::block_x"]
        [::core::mem::offset_of!(astcenc_block_info, block_x) - 4usize];
    ["Offset of field: astcenc_block_info::block_y"]
        [::core::mem::offset_of!(astcenc_block_info, block_y) - 8usize];
    ["Offset of field: astcenc_block_info::block_z"]
        [::core::mem::offset_of!(astcenc_block_info, block_z) - 12usize];
    ["Offset of field: astcenc_block_info::texel_count"]
        [::core::mem::offset_of!(astcenc_block_info, texel_count) - 16usize];
    ["Offset of field: astcenc_block_info::is_error_block"]
        [::core::mem::offset_of!(astcenc_block_info, is_error_block) - 20usize];
    ["Offset of field: astcenc_block_info::is_constant_block"]
        [::core::mem::offset_of!(astcenc_block_info, is_constant_block) - 21usize];
    ["Offset of field: astcenc_block_info::is_hdr_block"]
        [::core::mem::offset_of!(astcenc_block_info, is_hdr_block) - 22usize];
    ["Offset of field: astcenc_block_info::is_dual_plane_block"]
        [::core::mem::offset_of!(astcenc_block_info, is_dual_plane_block) - 23usize];
    ["Offset of field: astcenc_block_info::partition_count"]
        [::core::mem::offset_of!(astcenc_block_info, partition_count) - 24usize];
    ["Offset of field: astcenc_block_info::partition_index"]
        [::core::mem::offset_of!(astcenc_block_info, partition_index) - 28usize];
    ["Offset of field: astcenc_block_info::dual_plane_component"]
        [::core::mem::offset_of!(astcenc_block_info, dual_plane_component) - 32usize];
    ["Offset of field: astcenc_block_info::color_endpoint_modes"]
        [::core::mem::offset_of!(astcenc_block_info, color_endpoint_modes) - 36usize];
    ["Offset of field: astcenc_block_info::color_level_count"]
        [::core::mem::offset_of!(astcenc_block_info, color_level_count) - 52usize];
    ["Offset of field: astcenc_block_info::weight_level_count"]
        [::core::mem::offset_of!(astcenc_block_info, weight_level_count) - 56usize];
    ["Offset of field: astcenc_block_info::weight_x"]
        [::core::mem::offset_of!(astcenc_block_info, weight_x) - 60usize];
    ["Offset of field: astcenc_block_info::weight_y"]
        [::core::mem::offset_of!(astcenc_block_info, weight_y) - 64usize];
    ["Offset of field: astcenc_block_info::weight_z"]
        [::core::mem::offset_of!(astcenc_block_info, weight_z) - 68usize];
    ["Offset of field: astcenc_block_info::color_endpoints"]
        [::core::mem::offset_of!(astcenc_block_info, color_endpoints) - 72usize];
    ["Offset of field: astcenc_block_info::weight_values_plane1"]
        [::core::mem::offset_of!(astcenc_block_info, weight_values_plane1) - 200usize];
    ["Offset of field: astcenc_block_info::weight_values_plane2"]
        [::core::mem::offset_of!(astcenc_block_info, weight_values_plane2) - 1064usize];
    ["Offset of field: astcenc_block_info::partition_assignment"]
        [::core::mem::offset_of!(astcenc_block_info, partition_assignment) - 1928usize];
};
    #[doc = " Populate a codec config based on default settings.\n\n Power users can edit the returned config struct to fine tune before allocating the context.\n\n @param      profile   Color profile.\n @param      block_x   ASTC block size X dimension.\n @param      block_y   ASTC block size Y dimension.\n @param      block_z   ASTC block size Z dimension.\n @param      quality   Search quality preset / effort level. Either an\n                       @c ASTCENC_PRE_* value, or a effort level between 0\n                       and 100. Performance is not linear between 0 and 100.\n\n @param      flags     A valid set of @c ASTCENC_FLG_* flag bits.\n @param[out] config    Output config struct to populate.\n\n @return @c ASTCENC_SUCCESS on success, or an error if the inputs are invalid\n either individually, or in combination."]
    pub unsafe fn astcenc_config_init(
        profile: astcenc_profile,
        block_x: ::core::ffi::c_uint,
        block_y: ::core::ffi::c_uint,
        block_z: ::core::ffi::c_uint,
        quality: f32,
        flags: ::core::ffi::c_uint,
        config: *mut astcenc_config,
    ) -> astcenc_error {
        crate::src::astcenc_entry_cbe:: _Z19astcenc_config_init15astcenc_profilejjjfjP14astcenc_config(profile, block_x, block_y, block_z, quality, flags, config.cast())
    }
    #[doc = " @brief Allocate a new codec context based on a config.\n\n This function allocates all of the memory resources and threads needed by the codec. This can be\n slow, so it is recommended that contexts are reused to serially compress or decompress multiple\n images to amortize setup cost.\n\n Contexts can be allocated to support only decompression using the @c ASTCENC_FLG_DECOMPRESS_ONLY\n flag when creating the configuration. The compression functions will fail if invoked. For a\n decompress-only library build the @c ASTCENC_FLG_DECOMPRESS_ONLY flag must be set when creating\n any context.\n\n @param[in]  config         Codec config.\n @param      thread_count   Thread count to configure for.\n @param[out] context        Location to store an opaque context pointer.\n\n @return @c ASTCENC_SUCCESS on success, or an error if context creation failed."]
    pub unsafe fn astcenc_context_alloc(
        config: *const astcenc_config,
        thread_count: ::core::ffi::c_uint,
        context: *mut *mut astcenc_context,
    ) -> astcenc_error {
        crate::src::astcenc_entry_cbe::_Z21astcenc_context_allocPK14astcenc_configjPP15astcenc_context(config.cast_mut().cast(), thread_count, context.cast())
    }
    #[doc = " @brief Compress an image.\n\n A single context can only compress or decompress a single image at a time.\n\n For a context configured for multi-threading, any set of the N threads can call this function.\n Work will be dynamically scheduled across the threads available. Each thread must have a unique\n @c thread_index.\n\n @param         context        Codec context.\n @param[in,out] image          An input image, in 2D slices.\n @param         swizzle        Compression data swizzle, applied before compression.\n @param[out]    data_out       Pointer to output data array.\n @param         data_len       Length of the output data array.\n @param         thread_index   Thread index [0..N-1] of calling thread.\n\n @return @c ASTCENC_SUCCESS on success, or an error if compression failed."]
    pub unsafe fn astcenc_compress_image(
        context: *mut astcenc_context,
        image: *mut astcenc_image,
        swizzle: *const astcenc_swizzle,
        data_out: *mut u8,
        data_len: usize,
        thread_index: ::core::ffi::c_uint,
    ) -> astcenc_error {
        crate::src::astcenc_entry_cbe::_Z22astcenc_compress_imageP15astcenc_contextP13astcenc_imagePK15astcenc_swizzlePhmj(context.cast(), image.cast(),swizzle.cast_mut().cast(), data_out.cast(), u64::try_from(data_len).unwrap(), thread_index)
    }
    #[doc = " @brief Reset the codec state for a new compression.\n\n The caller is responsible for synchronizing threads in the worker thread pool. This function must\n only be called when all threads have exited the @c astcenc_compress_image() function for image N,\n but before any thread enters it for image N + 1.\n\n Calling this is not required (but won't hurt), if the context is created for single threaded use.\n\n @param context   Codec context.\n\n @return @c ASTCENC_SUCCESS on success, or an error if reset failed."]
    pub unsafe fn astcenc_compress_reset(context: *mut astcenc_context) -> astcenc_error {
        crate::src::astcenc_entry_cbe::_Z22astcenc_compress_resetP15astcenc_context(context.cast())
    }
    #[doc = " @brief Cancel any pending compression operation.\n\n The caller must behave as if the compression completed normally, even though the data will be\n undefined. They are still responsible for synchronizing threads in the worker thread pool, and\n must call reset before starting another compression.\n\n @param context   Codec context.\n\n @return @c ASTCENC_SUCCESS on success, or an error if cancellation failed."]
    pub unsafe fn astcenc_compress_cancel(context: *mut astcenc_context) -> astcenc_error {
        crate::src::astcenc_entry_cbe::_Z23astcenc_compress_cancelP15astcenc_context(context.cast())
    }
    #[doc = " @brief Decompress an image.\n\n @param         context        Codec context.\n @param[in]     data           Pointer to compressed data.\n @param         data_len       Length of the compressed data, in bytes.\n @param[in,out] image_out      Output image.\n @param         swizzle        Decompression data swizzle, applied after decompression.\n @param         thread_index   Thread index [0..N-1] of calling thread.\n\n @return @c ASTCENC_SUCCESS on success, or an error if decompression failed."]
    pub unsafe fn astcenc_decompress_image(
        context: *mut astcenc_context,
        data: *const u8,
        data_len: usize,
        image_out: *mut astcenc_image,
        swizzle: *const astcenc_swizzle,
        thread_index: ::core::ffi::c_uint,
    ) -> astcenc_error {
        crate::src::astcenc_entry_cbe::_Z24astcenc_decompress_imageP15astcenc_contextPKhmP13astcenc_imagePK15astcenc_swizzlej(context.cast(), data.cast_mut().cast(), u64::try_from(data_len).unwrap(), image_out.cast(), swizzle.cast_mut().cast(), thread_index)
    }
    #[doc = " @brief Reset the codec state for a new decompression.\n\n The caller is responsible for synchronizing threads in the worker thread pool. This function must\n only be called when all threads have exited the @c astcenc_decompress_image() function for image\n N, but before any thread enters it for image N + 1.\n\n Calling this is not required (but won't hurt), if the context is created for single threaded use.\n\n @param context   Codec context.\n\n @return @c ASTCENC_SUCCESS on success, or an error if reset failed."]
    pub unsafe fn astcenc_decompress_reset(context: *mut astcenc_context) -> astcenc_error {
        crate::src::astcenc_entry_cbe::_Z24astcenc_decompress_resetP15astcenc_context(context.cast())
    }
    #[doc = " Free the compressor context.\n\n @param context   The codec context."]
    pub unsafe fn astcenc_context_free(context: *mut astcenc_context) {
        crate::src::astcenc_entry_cbe::_Z20astcenc_context_freeP15astcenc_context(context.cast())
    }
    #[doc = " @brief Provide a high level summary of a block's encoding.\n\n This feature is primarily useful for codec developers but may be useful for developers building\n advanced content packaging pipelines.\n\n @param context   Codec context.\n @param data      One block of compressed ASTC data.\n @param info      The output info structure to populate.\n\n @return @c ASTCENC_SUCCESS if the block was decoded, or an error otherwise. Note that this\n         function will return success even if the block itself was an error block encoding, as the\n         decode was correctly handled."]
    pub unsafe fn astcenc_get_block_info(
        context: *mut astcenc_context,
        data: *const u8,
        info: *mut astcenc_block_info,
    ) -> astcenc_error {
        crate::src::astcenc_entry_cbe::_Z22astcenc_get_block_infoP15astcenc_contextPKhP18astcenc_block_info(context.cast(), data.cast_mut().cast(), info.cast())
    }
    #[doc = " @brief Get a printable string for specific status code.\n\n @param status   The status value.\n\n @return A human readable nul-terminated string."]
    pub unsafe fn astcenc_get_error_string(status: astcenc_error) -> *const ::core::ffi::c_char {
        crate::src::astcenc_entry_cbe::_Z24astcenc_get_error_string13astcenc_error(status).cast_const().cast()
    }

